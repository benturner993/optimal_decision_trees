test[which(y%%X = 0)]
test[which(y%%X == 0)]
test[which(y%%x == 0)]
test <- cbind(y,y%%x); test
test <- cbind(y,y%%x = x); test
test <- cbind(y,x%%y); test
# GCD is the maximum of that list
test[which(y%%x == 0)]
y[x%%y==0]
# a to find all the integers that divide x with remainder 0
x = 100; x
y = 1:x; y
test <- cbind(y,x%%y); test
# GCD is the maximum of that list
y[x%%y==0]
divisors <- cbind(y1,x1%%y1); divisors
y1 = 1:x1; y1
divisors <- cbind(y1,x1%%y1); divisors
# a to find all the integers that divide x with remainder 0
x1 = 100; x1
y1 = 1:x1; y1
divisors <- cbind(y1,x1%%y1); divisors
# GCD is the maximum of that list
y1[x1%%y1==0]
x2 = 200; x2
y2 = 1:x2; y2
divisors <- cbind(y2,x2%%y2); divisors
# GCD is the maximum of that list
y2[x2%%y2==0]
divisors1 = divisors2
divisors1 = divisors2
# Find common multiples for x2
x2 = 200; x2
y2 = 1:x2; y2
divisors2 <- cbind(y2,x2%%y2); divisors2
divisors1 = divisors2
# Find common multiples for x1
x1 = 100; x1
y1 = 1:x1; y1
divisors1 <- cbind(y1,x1%%y1); divisors1
# GCD is the maximum of that list
y1[x1%%y1==0]
# Find common multiples for x2
x2 = 200; x2
y2 = 1:x2; y2
divisors2 <- cbind(y2,x2%%y2); divisors2
y2[x2%%y2==0]
intersect(divisors1, divisors2)
divisors2 <- cbind(y2,x2%%y2); divisors2
divisors1 <- cbind(y1=y1,y2 =x1%%y1); divisors1
rm(list=ls())
# Find common multiples for x1
x1 = 100; x1
y1 = 1:x1; y1
divisors1 <- cbind(Range=y1,Divisors =x1%%y1); divisors1
# Find common multiples for x2
x2 = 200; x2
y2 = 1:x2; y2
divisors2 <- cbind(Range = y2, Divisors = x2%%y2); divisors2
# Find intersecting value
intersect(divisors1%Divsors, divisors2%Divisors)
# Find intersecting value
intersect(divisors1$Divisors, divisors2$Divisors)
# Find intersecting value
intersect(divisors1[,2], divisors2[,2])
divisors1[,2],
divisors1[,2]
# Find intersecting value
max(intersect(divisors1[,2], divisors2[,2]))
divisors2[,2]
rm(list=ls())
divisors1 <- cbind(Range=y1,Divisors =y1%%x1); divisors1
# Find common multiples for x1
x1 = 100; x1
y1 = 1:x1; y1
divisors1 <- cbind(Range=y1,Divisors =y1%%x1); divisors1
# Find common multiples for x2
x2 = 200; x2
y2 = 1:x2; y2
divisors2 <- cbind(Range = y2, Divisors = y2%%x2); divisors2
# Find intersecting value
max(intersect(divisors1[,2], divisors2[,2]))
divisors3 <- cbind(Range = y2, Divisors = x2%%y2==0); divisors3
# Find common multiples for x1
x1 = 100; x1
y1 = 1:x1; y1
rm(list=ls())
# Find common multiples for x1
x1 = 100; x1
y1 = 1:x1; y1
divisors1 <- cbind(Range=y1,Divisors =x1%%y1); divisors1
divisors1$range[divisors1$Divisors ==0 ]
y1[x1%%y1 ==0 ]
divisors1 <- cbind(Range=y1[x1%%y1 ==0],Divisors =x1%%y1); divisors1
y1[x1%%y1 ==0]
# Find common multiples for x2
x2 = 200; x2
y2 = 1:x2; y2
a = y1[x1%%y1 ==0]
b = y2[x2%%y2 ==0]
intersect(a,b)
max(intersect(a,b))
rm(list=ls())
# Find common multiples for x1
x1 = 100; x1
y1 = 1:x1; y1
x2 = 200; x2
y2 = 1:x2; y2
a = y1[x1%%y1 ==0]
b = y2[x2%%y2 ==0]
max(intersect(a,b))
# Find common multiples for x1
x1 = 700; x1
y1 = 1:x1; y1
x2 = 200; x2
y2 = 1:x2; y2
a = y1[x1%%y1 ==0]
b = y2[x2%%y2 ==0]
max(intersect(a,b))
# Find common multiples for x1
x1 = 700; x1
y1 = 1:x1; y1
x2 = 5931; x2
y2 = 1:x2; y2
a = y1[x1%%y1 ==0]
b = y2[x2%%y2 ==0]
max(intersect(a,b))
a = y1[x1%%y1 ==0]; a
finalmark <- function(x,y) {
0.2*x + 0.8*y
}
q1a <- function(x,y) {
0.2*x + 0.8*y
}
answer <- q1a(x-20,80); answer
q1a <- function(x,y) {
answer = 0.2*x + 0.8*y
}
answer <- q1a(x-20,80); answer
answer <- q1a(x=20,80); answer
answer <- q1a(20,80); answer
q1a <- function(x,y) {
answer = 0.2*x + 0.8*y
}
answer <- q1a(20,80); answer
q1a <- function(x,y) {
answer = 0.2*x + 0.8*y
}
answer <- q1a(20,80); answer
q1a <- function(x,y) {
answer = 0.2*x + 0.8*y
}
answer <- q1a(20,80); answer
answer <- q1a(290,80); answer
answer <- q1a(90,80); answer
answer <- q1a(963250,80); answer
y1 = (y1<-seq(40,100,by=1))
y1 = (y1<-seq(40,100,by=1)); y1
q1b <- function(x,y){
answer = min(x+10, 0.2*x+0.8*y)
}
answer <- q1b(10,50); answer
GCD <- function(x1,x2){
# Define the two values to find the GCD, x1 and x2 respectively.
x1 = 700; x1
x2 = 5931; x2
# Find the range of integers between 1 and x1 and x2 as y1 and y2 respectively.
y1 = 1:x1; y1
y2 = 1:x2; y2
# Find the divisors (between x1 and y1) where the remainder is 0, called a
a = y1[x1%%y1==0]; a
# Find the divisors (between x2 and y2) where the remainder is 0, called b
b = y2[x2%%y2==0]; b
# Find the greatest common value in a and b
GCD = max(intersect(a,b)); GCD
}
GCD <- function(x1,x2){
# Define the two values to find the GCD, x1 and x2 respectively.
x1 = 700; x1
x2 = 5931; x2
# Find the range of integers between 1 and x1 and x2 as y1 and y2 respectively.
y1 = 1:x1; y1
y2 = 1:x2; y2
# Find the divisors (between x1 and y1) where the remainder is 0, called a
a = y1[x1%%y1==0]; a
# Find the divisors (between x2 and y2) where the remainder is 0, called b
b = y2[x2%%y2==0]; b
# Find the greatest common value in a and b
GCD = max(intersect(a,b)); GCD
}
# 1a The final mark is 0.2 x + 0.8 y.
q1a <- function(x,y) {
finalmark = 0.2*x + 0.8*y
}
finalmark <- q1a(50,80); finalmark
0.4*(20)+0.6*(35)
x <- 20
y <- 30
result <- cbind(x,y)
end_result <- max(10+y[x>80], 0.2*x+0.8*y)
end_result
q1c <- function(x,y){
min((y[x>=40]+x[x>=40])/2,y[y<40]-10)
}
#Coursework
x <- 20
# Exam
y <- 30
answer <- q1c(30,80); answer
q1c <- function(x,y){
min((y[x>=40]+x[x>=40])/2,y[x<40]-10)
}
answer <- q1c(30,80); answer
q1c <- function(x,y){
min((y[x>=40]+x[x>=40])/2,y[x<40]-10)
}
answer <- q1c(30,80); answer
#Coursework
x <- 78
# Exam
y <- 30
q1c <- function(x,y){
min((y[x>=40]+x[x>=40])/2,y[x<40]-10)
}
answer <- q1c(30,80); answer
min((y[x>=40]+x[x>=40])/2), (max(y[x<40]-10,0)))
q1c <- function(x,y){
min((y[x>=40]+x[x>=40])/2), (max(y[x<40]-10,0)))
}
q1c <- function(x,y){
min(((y[x>=40]+x[x>=40])/2), (max(y[x<40]-10,0)))
}
answer <- q1c(30,80); answer
# Exam
y <- 30
q1c <- function(x,y){
min(((y[x>=40]+x[x>=40])/2), (max(y[x<40]-10,0)))
}
answer <- q1c(30,80); answer
answer <- q1c(10,80); answer
answer <- q1c(50,80); answer
q1c <- function(x,y){
max(((y[x>=40]+x[x>=40])/2), (max(y[x<40]-10,0)))
}
answer <- q1c(50,80); answer
answer <- q1c(35,80); answer
# 1c
# If x ≥ 40 the final mark is the average of marks, otherwise the final mark is y − 10.
q1c <- function(x,y){
max(((y[x>=40]+x[x>=40])/2), (max(y[x<40]-10,0)))
}
answer <- q1c(70,70); answer
answer <- q1c(2,70); answer
answer <- q1c(80,80); answer
answer <- q1c(39,80); answer
GCD <- function(x1,x2){
# Define the two values to find the GCD, x1 and x2 respectively.
#x1 = 700; x1
#x2 = 5931; x2
# Find the range of integers between 1 and x1 and x2 as y1 and y2 respectively.
y1 = 1:x1; y1
y2 = 1:x2; y2
# Find the divisors (between x1 and y1) where the remainder is 0, called a
a = y1[x1%%y1==0]; a
# Find the divisors (between x2 and y2) where the remainder is 0, called b
b = y2[x2%%y2==0]; b
# Find the greatest common value in a and b
GCD = max(intersect(a,b)); GCD
}
GCD(100,200)
GCD(150,200)
# Define the two values to find the GCD, x1 and x2 respectively.
GCD <- function(x1,x2){
# Find the range of integers between 1 and x1 and x2 as y1 and y2 respectively.
y1 = 1:x1; y1
y2 = 1:x2; y2
# Find the divisors (between x1 and y1) where the remainder is 0, called a
a = y1[x1%%y1==0]; a
# Find the divisors (between x2 and y2) where the remainder is 0, called b
b = y2[x2%%y2==0]; b
# Find the greatest common value in a and b
GCD = max(intersect(a,b)); GCD
}
GCD(100,200)
GCD <- function(x1,x2){
# Define the two values to find the GCD, x1 and x2 respectively. Ensuring no negative values
x1 = abs(x1)
x2 = abs(x2)
# Find the range of integers between 1 and x1 and x2 as y1 and y2 respectively.
y1 = 1:x1; y1
y2 = 1:x2; y2
# Find the divisors (between x1 and y1) where the remainder is 0, called a
a = y1[x1%%y1==0]; a
# Find the divisors (between x2 and y2) where the remainder is 0, called b
b = y2[x2%%y2==0]; b
# Find the greatest common value in a and b
GCD = max(intersect(a,b)); GCD
}
GCD(-100,200)
GCD(-100,-200)
GCD(7,49)
GCD(7,-49)
GCD(7,-49)
# 6b
i = 1:48
j = 1:10
# All possible permutations of the double summations
df <- (expand.grid(i = i,j = j))
# Formula
sum(((df$i^2 + 7)*(df$j+50))^1/3)
# All possible permutations of the double summations
df <- (expand.grid(i = i,j = j)); df
# Formula
sum(((df$i^2 + 7)*(df$j+50))^1/3)
# 6a
i = 1:32
# Formula
sum((i^3 + log(5))^1/2)
# Formula
sum((i^3 + log(5))^(1/2))
# Formula
sum(((df$i^2 + 7)*(df$j+50))^(1/3))
# 6b
i = 1:48
j = 1:10
# All possible permutations of the double summations
df <- (expand.grid(i = i,j = j)); df
# Formula
sum(((df$i^2 + 7)*(df$j+50))^(1/3))
# Formula
sum(((df$i^2 + 7)*((df$j+50))^(1/3)))
# Formula
sum((((df$i)^2 + 7)*(df$j+50))^(1/3)
# Formula
sum((((df$i)^2 + 7))*(df$j+50))^(1/3)
# Formula
sum((((df$i)^2 + 7))*(df$j+50))^(1/3)
# 6b
i = 1:48
j = 1:10
# All possible permutations of the double summations
df <- (expand.grid(i = i,j = j)); df
# Formula
sum((((df$i)^2 + 7))*(df$j+50))^(1/3)
fit <- lm(y ~ x1 + x2 + x3)
df <- (x1, x2, x3, y)
df <- c(x1, x2, x3, y)
x1 <- c(9,6,7,12,4,9,2,6,1,8)
x2 <- c(1,6,3,11,1,2,7,6,1,3)
x3 <- c(0,1,1,1,1,1,0,0,1,1)
y <- c(8.5,11,12,20,9,5.5,11,5,2.3,12)
df <- c(x1, x2, x3, y)
df
x1 <- c(9,6,7,12,4,9,2,6,1,8)
x2 <- c(1,6,3,11,1,2,7,6,1,3)
x3 <- c(0,1,1,1,1,1,0,0,1,1)
y <- c(8.5,11,12,20,9,5.5,11,5,2.3,12)
fit <- lm(y ~ x1 + x2 + x3, df)
df <- data.frame(
x1 <- c(9,6,7,12,4,9,2,6,1,8)
x2 <- c(1,6,3,11,1,2,7,6,1,3)
x3 <- c(0,1,1,1,1,1,0,0,1,1)
y <- c(8.5,11,12,20,9,5.5,11,5,2.3,12)
)
fit <- lm(y ~ x1 + x2 + x3, data = df)
df <- data.frame(
x1 <- c(9,6,7,12,4,9,2,6,1,8),
x2 <- c(1,6,3,11,1,2,7,6,1,3),
x3 <- c(0,1,1,1,1,1,0,0,1,1),
y <- c(8.5,11,12,20,9,5.5,11,5,2.3,12)
)
fit <- lm(y ~ x1 + x2 + x3, data = df)
summary(fit)
# matrix of predictors
X <- as.matrix(mydata[c("x1","x2","x3")])
mydata <- data.frame(
x1 <- c(9,6,7,12,4,9,2,6,1,8),
x2 <- c(1,6,3,11,1,2,7,6,1,3),
x3 <- c(0,1,1,1,1,1,0,0,1,1),
y <- c(8.5,11,12,20,9,5.5,11,5,2.3,12)
)
fit <- lm(y ~ x1 + x2 + x3, data = mydata)
# matrix of predictors
X <- as.matrix(mydata[c("x1","x2","x3")])
# vector of predicted values
y <- as.matrix(mydata[c("y")])
X <- as.matrix(mydata[c("x1","x2","x3")])
mydata;
view(mydata);
View(mydata);
mydata <- data.frame(1,x1,x2,x3)
# matrix of predictors
X <- as.matrix(mydata[c("x1","x2","x3")])
# vector of predicted values
y <- as.matrix(mydata[c("y")])
mydata <- data.frame(1,x1,x2,x3, y)
# matrix of predictors
X <- as.matrix(mydata[c("x1","x2","x3")])
# vector of predicted values
y <- as.matrix(mydata[c("y")])
b<-solve(t(X)%*%X)%*%t(X)%*%y
b<-solve(crossprod(X), crossprod(X,y))
n = 1000
summary(b)
summary(b)
summary(fit)
summary(b)
b
df <- data.frame(
x1 <- c(9,6,7,12,4,9,2,6,1,8),
x2 <- c(1,6,3,11,1,2,7,6,1,3),
x3 <- c(0,1,1,1,1,1,0,0,1,1),
y <- c(8.5,11,12,20,9,5.5,11,5,2.3,12)
)
fit <- lm(y ~ x1 + x2 + x3, data = df)
summary(fit)
b<-solve(crossprod(X,x), crossprod(X,y))
# matrix of predictors
X <- as.matrix(mydata[c("x1","x2","x3")])
# vector of predicted values
y <- as.matrix(mydata[c("y")])
b<-solve(t(X)%*%X)%*%t(X)%*%y
b<-solve(crossprod(X,x), crossprod(X,y))
b<-solve(crossprod(X,x)), crossprod(X,y))
b<-solve(crossprod(X), crossprod(X,y))
b
summary(fit)
# matrix of predictors
X <- as.matrix(mydata[c(1, "x1","x2","x3")])
# matrix of predictors
X <- as.matrix(mydata[c("1", "x1","x2","x3")])
# vector of predicted values
y <- as.matrix(mydata[c("y")])
b<-solve(t(X)%*%X)%*%t(X)%*%y
b<-solve(crossprod(X), crossprod(X,y))
b
fit <- lm(y ~ x1 + x2 + x3, data = df)
summary(fit)
df <- data.frame(
x0 <- c(0,0,0,0,0,0,0,0,0,0),
x1 <- c(9,6,7,12,4,9,2,6,1,8),
x2 <- c(1,6,3,11,1,2,7,6,1,3),
x3 <- c(0,1,1,1,1,1,0,0,1,1),
y <- c(8.5,11,12,20,9,5.5,11,5,2.3,12)
)
df <- data.frame(
x0 <- c(1,1,1,1,1,1,1,1,1,1),
x1 <- c(9,6,7,12,4,9,2,6,1,8),
x2 <- c(1,6,3,11,1,2,7,6,1,3),
x3 <- c(0,1,1,1,1,1,0,0,1,1),
y <- c(8.5,11,12,20,9,5.5,11,5,2.3,12)
)
fit <- lm(y ~ x1 + x2 + x3, data = df)
summary(fit)
# matrix of predictors
X <- as.matrix(mydata[c("x0","x1","x2","x3")])
df <- data.frame(
x0 <- c(1,1,1,1,1,1,1,1,1,1),
x1 <- c(9,6,7,12,4,9,2,6,1,8),
x2 <- c(1,6,3,11,1,2,7,6,1,3),
x3 <- c(0,1,1,1,1,1,0,0,1,1),
y <- c(8.5,11,12,20,9,5.5,11,5,2.3,12)
)
x0 <- c(1,1,1,1,1,1,1,1,1,1)
# matrix of predictors
X <- as.matrix(mydata[c("x0","x1","x2","x3")])
mydata <- data.frame(x0,x1,x2,x3, y)
# matrix of predictors
X <- as.matrix(mydata[c("x0","x1","x2","x3")])
# vector of predicted values
y <- as.matrix(mydata[c("y")])
b<-solve(crossprod(X), crossprod(X,y))
b
summary(fit)
summary(b)
b<-solve(t(X)%*%X)%*%t(X)%*%y
b
b<-solve(t(X)%*%X)%*%t(X)%*%y
b
b<-(t(X)%*%X)%*%t(X)%*%y
b
fit <- lm(y ~ x1 + x2 + x3, data = df)
summary(fit)
5+5
install.packages("iai")
library(iai)
library(iai)
# Set current working directory
setwd("/Users/Ben/Desktop/optimal_decision_trees")
# In this example we will use Optimal Classification Trees (OCT) on the banknote authentication
# dataset. First we load in the data and split into training and test datasets:
df <- read.table("data_banknote_authentication.txt", sep = ",",
col.names = c("variance", "skewness", "curtosis", "entropy",
"class"))
# Optimal Classification Trees
X <- df[, 1:4]
y <- df[, 5]
split <- iai::split_data("classification", X, y, seed = 1)
library(iai)
# Set current working directory
setwd("/Users/Ben/Desktop/optimal_decision_trees")
# In this example we will use Optimal Classification Trees (OCT) on the banknote authentication
# dataset. First we load in the data and split into training and test datasets:
df <- read.table("data_banknote_authentication.txt", sep = ",",
col.names = c("variance", "skewness", "curtosis", "entropy",
"class"))
# Optimal Classification Trees
X <- df[, 1:4]
y <- df[, 5]
split <- iai::split_data("classification", X, y, seed = 1)
train_X <- split$train$X
train_y <- split$train$y
